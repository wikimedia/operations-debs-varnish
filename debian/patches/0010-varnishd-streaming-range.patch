diff --git a/bin/varnishd/cache.h b/bin/varnishd/cache.h
index 0ad00d8..0ed2f96 100644
--- a/bin/varnishd/cache.h
+++ b/bin/varnishd/cache.h
@@ -285,7 +285,7 @@ struct stream_ctx {
 	ssize_t			stream_front;
 	struct storage		*stream_frontchunk;
 
-	/* Max byte we can stream */
+	/* Max byte count we can stream at a given moment */
 	ssize_t			stream_max;
 };
 
@@ -910,11 +910,11 @@ void WSL_Flush(struct worker *w, int overflow);
 /* cache_response.c */
 void RES_BuildHttp(const struct sess *sp);
 void RES_WriteObj(struct sess *sp);
-void RES_StreamStart(struct sess *sp);
+void RES_StreamStart(struct sess *sp, ssize_t *plow, ssize_t *phigh);
 void RES_StreamEnd(struct sess *sp);
 int RES_StreamPoll(const struct sess *sp);
 void RES_StreamWrite(const struct sess *sp);
-void RES_StreamBody(struct sess *sp);
+void RES_StreamBody(struct sess *sp, const ssize_t start, const ssize_t end);
 
 /* cache_vary.c */
 struct vsb *VRY_Create(const struct sess *sp, const struct http *hp);
diff --git a/bin/varnishd/cache_center.c b/bin/varnishd/cache_center.c
index 61d3fb4..27038b7 100644
--- a/bin/varnishd/cache_center.c
+++ b/bin/varnishd/cache_center.c
@@ -923,16 +923,17 @@ DOT }
 static int
 cnt_streamdeliver(struct sess *sp)
 {
+	ssize_t low, high;
 	struct busyobj *bo;
 
 	bo = sp->stream_busyobj;
 	CHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);
 
-	RES_StreamStart(sp);
+	RES_StreamStart(sp, &low, &high);
 	sp->wrk->h_content_length = NULL;
 
 	if (sp->wantbody)
-		RES_StreamBody(sp);
+		RES_StreamBody(sp, low, (high == -1 ? SSIZE_MAX : high + 1));
 
 	RES_StreamEnd(sp);
 
diff --git a/bin/varnishd/cache_response.c b/bin/varnishd/cache_response.c
index bdd967c..481c28e 100644
--- a/bin/varnishd/cache_response.c
+++ b/bin/varnishd/cache_response.c
@@ -43,7 +43,7 @@
 /*--------------------------------------------------------------------*/
 
 static void
-res_dorange(const struct sess *sp, const char *r, ssize_t *plow, ssize_t *phigh)
+res_dorange(const struct sess *sp, const char *r, const ssize_t content_len, ssize_t *plow, ssize_t *phigh)
 {
 	ssize_t low, high, has_low;
 
@@ -63,7 +63,7 @@ res_dorange(const struct sess *sp, const char *r, ssize_t *plow, ssize_t *phigh)
 		r++;
 	}
 
-	if (low >= sp->obj->len)
+	if (low >= content_len)
 		return;
 
 	if (*r != '-')
@@ -79,23 +79,23 @@ res_dorange(const struct sess *sp, const char *r, ssize_t *plow, ssize_t *phigh)
 			r++;
 		}
 		if (!has_low) {
-			low = sp->obj->len - high;
-			high = sp->obj->len - 1;
+			low = content_len - high;
+			high = content_len - 1;
 		}
 	} else
-		high = sp->obj->len - 1;
+		high = content_len - 1;
 	if (*r != '\0')
 		return;
 
-	if (high >= sp->obj->len)
-		high = sp->obj->len - 1;
+	if (high >= content_len)
+		high = content_len - 1;
 
 	if (low > high)
 		return;
 
 	http_PrintfHeader(sp->wrk, sp->fd, sp->wrk->resp,
 	    "Content-Range: bytes %jd-%jd/%jd",
-	    (intmax_t)low, (intmax_t)high, (intmax_t)sp->obj->len);
+	    (intmax_t)low, (intmax_t)high, (intmax_t)content_len);
 	http_Unset(sp->wrk->resp, H_Content_Length);
 	assert(sp->wrk->res_mode & RES_LEN);
 	http_PrintfHeader(sp->wrk, sp->fd, sp->wrk->resp,
@@ -285,7 +285,7 @@ RES_WriteObj(struct sess *sp)
 	    params->http_range_support &&
 	    sp->obj->response == 200 &&
 	    http_GetHdr(sp->http, H_Range, &r))
-		res_dorange(sp, r, &low, &high);
+		res_dorange(sp, r, sp->obj->len, &low, &high);
 
 	/*
 	 * Always remove C-E if client don't grok it
@@ -334,8 +334,11 @@ RES_WriteObj(struct sess *sp)
 /*--------------------------------------------------------------------*/
 
 void
-RES_StreamStart(struct sess *sp)
+RES_StreamStart(struct sess *sp, ssize_t *plow, ssize_t *phigh)
 {
+	char *r;
+	ssize_t content_len;
+
 	AZ(sp->wrk->res_mode & RES_ESI_CHILD);
 
 	WRW_Reserve(sp->wrk, &sp->fd);
@@ -350,6 +353,27 @@ RES_StreamStart(struct sess *sp)
 	}
 
 	/*
+	 * If nothing special planned, we can attempt Range support
+	 */
+	*plow = 0;
+	*phigh = -1;
+	if (
+		sp->wantbody &&
+		(sp->wrk->res_mode & RES_LEN) &&
+		!(sp->wrk->res_mode & (RES_ESI|RES_ESI_CHILD|RES_GUNZIP|RES_CHUNKED)) &&
+		params->http_range_support &&
+		sp->obj->response == 200 &&
+		sp->wrk->h_content_length != NULL &&
+		http_GetHdr(sp->http, H_Range, &r)) {
+			/* We don't have sp->obj->len in streaming mode, so we'll have
+			 * to parse the response's Content-Length header
+			 */
+			content_len = strtol(sp->wrk->h_content_length, NULL, 10);
+			if (content_len >= 0 && content_len != LONG_MAX)
+				res_dorange(sp, r, content_len, plow, phigh);
+	}
+
+	/*
 	 * Always remove C-E if client don't grok it
 	 */
 	if (sp->wrk->res_mode & RES_GUNZIP)
@@ -359,9 +383,12 @@ RES_StreamStart(struct sess *sp)
 		sp->wrk->res_mode &= ~RES_CHUNKED;
 
 	if (!(sp->wrk->res_mode & RES_CHUNKED) &&
-	    sp->wrk->h_content_length != NULL && sp->wantbody)
+	    sp->wrk->h_content_length != NULL &&
+		sp->wantbody && *phigh == -1) {
+		http_Unset(sp->wrk->resp, H_Content_Length);
 		http_PrintfHeader(sp->wrk, sp->fd, sp->wrk->resp,
 		    "Content-Length: %s", sp->wrk->h_content_length);
+	}
 
 	sp->wrk->acct_tmp.hdrbytes +=
 	    http_Write(sp->wrk, sp->wrk->resp, 1);
@@ -521,10 +548,13 @@ RES_StreamEnd(struct sess *sp)
  * iov's, thus returning from writev quickly. Releases token giving
  * the other fast writers a go, and clears the fast writer flag. If
  * still a fast writer will hit end-of-data again setting it again.
+ *
+ * When streaming, a thread hitting end of data will only be marked
+ * as a fast writer once the low end of the data range is available.
  */
 
 void
-RES_StreamBody(struct sess *sp)
+RES_StreamBody(struct sess *sp, const ssize_t start, const ssize_t end)
 {
 	struct stream_ctx sctx;
 	struct busyobj *bo;
@@ -543,15 +573,26 @@ RES_StreamBody(struct sess *sp)
 	AZ(sp->wrk->sctx);
 	sp->wrk->sctx = &sctx;
 
+	/* We may not send a full object if it's a Range request
+	 * end == SSIZE_MAX for a normal, non-Range request */
+	sctx.stream_next = start;
+
 	if (sp->wrk->res_mode & RES_GUNZIP) {
 		sctx.vgz = VGZ_NewUngzip(sp, "U S -");
 		sctx.obuf = obuf;
 		sctx.obuf_len = sizeof (obuf);
 	}
 
+	/* Invariant:
+	 *      sctx.stream_next <= sctx.stream_max || bo->stream_max < sctx.stream_next
+	 *      sctx.stream_max <= end
+	 *      sctx.stream_max <= bo->stream_max
+	 *      0 <= start < end <= SSIZE_MAX
+	 */
+
 	fast_writer = 0;
 	Lck_Lock(&bo->mtx);
-	while (!bo->stream_stop || sctx.stream_next < bo->stream_max) {
+	while (sctx.stream_next < end && (!bo->stream_stop || sctx.stream_next < bo->stream_max)) {
 		if (fast_writer) {
 			if (bo->stream_tokens == 0) {
 				Lck_CondWait(&bo->cond_tokens, &bo->mtx);
@@ -565,24 +606,28 @@ RES_StreamBody(struct sess *sp)
 			   would probably be able to do more work as well */
 			AZ(pthread_cond_signal(&bo->cond_data));
 		}
-		sctx.stream_max = bo->stream_max;
-		assert(sctx.stream_max >= sctx.stream_next);
-		Lck_Unlock(&bo->mtx);
-		RES_StreamWrite(sp);
-		Lck_Lock(&bo->mtx);
-		if (fast_writer) {
-			bo->stream_tokens++;
-			AZ(pthread_cond_signal(&bo->cond_tokens));
+		sctx.stream_max = (bo->stream_max < end ? bo->stream_max : end);
+		assert(sctx.stream_max >= sctx.stream_next || bo->stream_max <= start);
+		if (sctx.stream_next < sctx.stream_max) {
 			Lck_Unlock(&bo->mtx);
-			/* Release to give others a shot at the tokens */
+			RES_StreamWrite(sp);
 			Lck_Lock(&bo->mtx);
-			fast_writer = 0;
+			if (fast_writer) {
+				bo->stream_tokens++;
+				AZ(pthread_cond_signal(&bo->cond_tokens));
+				Lck_Unlock(&bo->mtx);
+				/* Release to give others a shot at the tokens */
+				Lck_Lock(&bo->mtx);
+				fast_writer = 0;
+			}
 		}
 		while (!bo->stream_stop &&
-		       sctx.stream_next == bo->stream_max) {
+			   sctx.stream_next < end &&
+			   sctx.stream_next >= bo->stream_max) {
 			/* Wait for more data */
 			Lck_CondWait(&bo->cond_data, &bo->mtx);
-			fast_writer = 1;
+			if (sctx.stream_next > start)
+				fast_writer = 1;
 		}
 		if (WRW_Error(sp->wrk))
 			break;
