diff --git a/bin/varnishd/storage_persistent_mgt.c b/bin/varnishd/storage_persistent_mgt.c
index ff10973..36e9c5d 100644
--- a/bin/varnishd/storage_persistent_mgt.c
+++ b/bin/varnishd/storage_persistent_mgt.c
@@ -39,6 +39,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/mman.h>
+#include <fcntl.h>
 
 #include "cache.h"
 #include "stevedore.h"
@@ -160,6 +161,29 @@ smp_mgt_init(struct stevedore *parent, int ac, char * const *av)
 
 	AZ(ftruncate(sc->fd, sc->mediasize));
 
+#if defined __linux__ && defined HAVE_FALLOCATE
+	/* fallocate new persistent files on Linux.
+	 * Notes:
+	 *   1) posix_fallocate() silently does horrible things if the kernel/fs
+	 *     doesn't have native support, hence direct fallocate() below.
+	 *   2) XFS (but not ext4) has an odd behavior where it will fail with
+	 *     ENOSPC when fallocate() is called for a second time on the same
+	 *     large file (> half fs size) that was already fallocate()'d earlier.
+	 */
+	if(fallocate(sc->fd, 0, 0, sc->mediasize)) {
+		if(errno == ENOSYS || errno == EOPNOTSUPP)
+			printf("Warning: (-spersistent): fallocate() not supported by kernel/fs for file %s\n",
+				sc->filename);
+		else
+			ARGV_ERR("(-spersistent): fallocate() for file %s failed: %s\n",
+				sc->filename, strerror(errno));
+	}
+	else {
+		printf("(-spersistent): file %s fallocate()'d to size %lli\n",
+			sc->filename, (long long int)sc->mediasize);
+	}
+#endif
+
 	/* Try to determine correct mmap address */
 	i = read(sc->fd, &sgn, sizeof sgn);
 	assert(i == sizeof sgn);
diff --git a/configure.ac b/configure.ac
index 306cf24..df55d80 100644
--- a/configure.ac
+++ b/configure.ac
@@ -199,6 +199,7 @@ AC_CHECK_FUNCS([abort2])
 AC_CHECK_FUNCS([timegm])
 AC_CHECK_FUNCS([nanosleep])
 AC_CHECK_FUNCS([setppriv])
+AC_CHECK_FUNCS([fallocate])
 
 save_LIBS="${LIBS}"
 LIBS="${PTHREAD_LIBS}"
